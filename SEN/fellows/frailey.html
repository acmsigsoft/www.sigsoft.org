<html>
<head>
<title>ACM SIGSOFT SEN: ACM Fellow Dennis J. Frailey</title>
<link rel="stylesheet" href="../sen.css" type="text/css">
</head>

<body>
<div id="container">
 <div id="banner">
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
   <tr>
    <td width="50%" valign="top" align="left"><img src="../images/sen_chevron_med.png" alt="Software Engineering Notes"></td>
    <td width="30%" valign="middle" align="center"><a href="http://www.acm.org/"><img src="../images/acmlogo_sg2007b.png" alt="ACM: Association for Computing Machinery" border="0"></a></td>
    <td width="20%" valign="middle" align="center"><a href="http://www.sigsoft.org/"><img src="../images/sigsoft_vsml.png" alt="SIGSOFT: Special Interest Group on Software Engineering" border="0"></a></td>
   </tr>
  </table>
 </div>

<div align="center"><br>
 <table border="0" cellpadding="0" cellspacing="0">
  <tr>
   <td width="75%" align="center" valign="middle">
    <h2><em>ACM Fellow Profile</em><br>
    Dennis J. Frailey</h2>
    <a href=mailto:fraileyd@acm.org>fraileyd@acm.org</a><br>
    <a href="http://www.seas.smu.edu/~frailey">www.seas.smu.edu/~frailey</a>
   </td>
   <td width="25%" align="center"><img src="images/fraileyg.gif" alt="Dennis Frailey photo"></td>
  </tr>
 </table>
</div>

<div class="indent10_10">
<p>
<strong><em>Please elaborate on the work leading up to your achieving the distinction of ACM Fellow:</em></strong><br>
A combination of research into operating systems and optimizing compilers; service in ACM and other
professional societies as an officer, program chairman, and facilitator; and many educational activities in
both the industrial and academic worlds.
</p>

<p>
<strong><em>In your "Software Project Planning and Management" course at SMU, you cover
several lifecycle models: waterfall, spiral and tornado.  How do you describe the tornado model?</em></strong><br>
This is actually a model for building life cycle models, developed by the corporate software engineering
process group at Texas Instruments in the early 1990's.  It starts with a simple construct called the "basic
development cycle," consisting of four generic steps: establish requirements, design, implement, and
evaluate.  This cycle is at the heart of just about every software life cycle model, indeed every product
development lifecycle.  In the tornado model, the basic cycle is used as a building block, with cycles fitted
together and tailored to form whatever lifecycle model is required.  As an example, the spiral model is a
sequence of increasingly larger basic cycles.  A waterfall is one basic cycle laid out in a sequence.  A
waterfall with a prototype during the design phase is simply a basic cycle that calls another one recursively
during the design step.  An outline of the model is included in the following paper:
</p>
<p>
<blockquote>"Concurrent Engineering and the Software Process,"  Frailey, Dennis J. in <strong>Proceedings, 2nd International
Conference on the Software Process</strong>, IEEE Computer Society Press, 1993, pp. 103-114, ISBN 0-8186-3600-9, IEEE catalog no. 93TH0509-0.
</blockquote>
</p>

<p>
<strong><em>What are your current research interests?</em></strong><br>
I do very little that would be construed as pure research these days. I have a lot of success taking ideas from
other disciplines and applying them to software engineering problems.  For example, my current technical
focus is improving software cycle time.  I'm borrowing and blending ideas from industrial engineering,
compiler optimization, and business process reengineering.  Much of my work is in educating and in
transitioning technology and knowledge between the academic and industrial communities, especially in the
areas of real time systems, software engineering metrics, and software process improvement.
</p>

<p>
<strong><em>What are your current outside interests?</em></strong><br>
Collecting mystery fiction, listening to classical and jazz music, and travelling.
</p>

<p>
<strong><em>What was the greatest influence on you?</em></strong><br>
My parents.  They believed in a sound, well-rounded education; taught me to love good music;
and encouraged me to become independent.
</p>

<p>
<strong><em>What was your greatest influence?</em></strong><br>
Inspiring many students and co-workers to become productive professionals and to be active members of
their professional associations.
</p>

<p>
<strong><em>Who do you think has made the greatest impact on software engineering?</em></strong><br>
Barry Boehm. Most of what we do in commercial software development is founded on his work in
software engineering economics, risk management and lifecycle models.
</p>

<p>
<strong><em>What's your favorite story about software engineering or development?</em></strong><br>
The bug that caused itself.  During my disseration work I wrote a self-compiler.  I found a bug having to do
with conversion of character strings representing real numbers into valid floating point constants.  In tracing
the source of the bug, I discovered that the bad constants generated by this bug were the cause of the error
in the conversion process!  I never did figure out how the bug got there in the first place, but I had to use
"bit tweezers" (patching binary punched cards) to fix the problem.
</p>

<p>
<strong><em>Which computer-related areas are most in need of investment by government,
business or education?</em></strong><br>
Developing a sound underlying foundation for software engineering, not just the design aspects but the
entire gamut of what is done to produce software, such as configuration management, quality engineering,
test engineering, and even document generation.
</p>

<p>
<strong><em>What advice do you have for computer science/software engineering students?</em></strong><br>
I have five points:<br>
<ol>
<li>Computing is an applied field and until you get immersed in the untidy world of actually developing and
applying software and computer systems, you will never truly understand many of the issues.  Seek
opportunities to get involved in real applications and then extract fundamental principles from what you have
learned.
</li>
<li>Computing is a marriage of hardware and software.  Many mistakes have been made by specialists in one
of these areas who did not understand the subtleties of the other.  Learn both hardware and software
principles if you seek to understand computing.
</li>
<li>All aspects of computing, no matter how seemingly mundane and lacking in established academic
foundations, are important and worthy.  I still recall the faculty committee who denied a student's Ph.D.
proposal because his research was in databases and they felt databases "had no academic merit."  This was
in the early 1970's, before people realized what an important and indeed academically rich field that is.  I
find that too many people even today have prejudices against some of the things we do in computing
because the theoretical foundations have not yet been established or the new things do not fit the established
mold, and thus people perceive them to be of lesser importance.
</li>
<li>Standardization and widespread use have been more important to success in computing than technical
superiority.  Just look at how the computing field evolved to see the truth of this.
</li>
<li>The small computers always take over the market from the larger ones.  Aim for the small systems.  In
the end, you will be dominant (until even smaller ones take over).  But learn your lessons from those who
worked before you on larger systems.  Reuse their ideas shamelessly.  To paraphrase Newton and
Hamming, learn to stand on the shoulders of giants.
</li>
</ol>
</p>

<p>
<strong><em>What is the most often-overlooked risk in software engineering?</em></strong><br>
The risk that you don't really understand what needs to be done -- especially when the software developer is
arrogant enough to think she or he knows better than the end user.
</p>

<p>
<strong><em>What is the most-repeated mistake in software engineering?</em></strong><br>
Failing to plan integration from the beginning.  Delaying the plan until the end and then discovering that you
should have done things very differently in order to make the parts come together smoothly.
<p>

<p>
<strong><em>What are the most exciting/promising software engineering ideas or techniques on the horizon?</em></strong><br>
Elimination of coding and testing through more effective, higher level tools and languages for analysis,
design, and quality engineering. Not only is this happening, but it MUST happen. Otherwise,
there will never be enough software developers to do the work.
</p>

<p>
<strong><em>What are your plans for the future or the next five years?</em></strong><br>
To be a part of the emerging software engineering education field.  I see it as the big growth area in
computing education and as offering many opportunities for innovative delivery of knowledge.
</p>

<p>
<strong><em>You've written about analogies between improving software and improving education; for example, you
compare designing around the I/O constraints of hardware to designing around students and their
constraints, such as work and home responsibilities.  What are some of the opportunities you see in the
software engineering education field, particularly with regard to non-traditional education channels or
settings?</em></strong><br>
I believe there will be a large growth in non-traditional education opportunities.  Here are some of the
growth areas I see right now:
<ul>
<li>Continuing education in software development and software project management for people
in various technical disciplines.  This will be driven by the ongoing shortage of well-qualified software
developers, software's ever-changing tools and methods, and the significant base of highly capable
technical people who find that software is playing a larger role in their work.</li>
<li>Backfilling for corporate training and education organizations.  I see many companies reducing
or diminishing the role of their in-house training organs due to pressures to cut overhead costs
and focus their efforts on their primary businesses.  They will increasingly turn to
subcontractors for this kind of education.  The need for the education and training will not go
away.</li>
<li>Preparation for certification and licensing.  There are programs already in place for
vendor-specific certification, software quality engineering certification, and several
others.  I see this expanding to other forms of certification and licensing as more
of these come along.</li>
</ul>
</p>

<p>
<strong><em>Who will provide this non-traditional education? And how?</em></strong><br>
A big part of this need will be served by commercial education and training companies, often small
one and two-person contractors.  I see this especially for focused topics, such as design methods,
software risk management, software cost estimating, and cycle time improvement. The university's
primary involvement may be through non-credit, continuing education programs.  There will also
be growth in masters degrees from traditional academic sources, such as computer science
and electrical engineering departments that offer software engineering degrees.  Other important
suppliers will be trade schools and community colleges. All of these will take advantage of distance
education and non-traditional delivery approaches, such as Internet, Computer Aided Instruction,
and weekend/evening education.  The key to serving this market is to realize that these are not
traditional students.  They are living, working, and having families.  One cannot serve them well
with the conventional "3 days a week on campus" education model.
</p>

<p>
<strong><em>You mentioned licensing. Do you think there will be a rapid increase in
states seeking to license software engineers?</em></strong><br>
I believe there will be a large growth in many forms of certification and licensing of software
practitioners.   These are mechanisms that society traditionally uses when faced with a flood of
people claiming to be qualified in a field where the layman cannot evaluate competence and where
there is potential for great harm by incompetent practitioners.  Licensing by states is especially likely
for safety-critical applications, and I suspect it will "take off" because political entities need a way to
respond to the growing public perception of genuine problems due to poorly developed software.
</p>

<p>
<strong><em>Please give us any additional comments for the profile:</em></strong><br>
Bill Wulf once said, "there is only one nature."  All the rest is human artifice.  Resist the urge to
associate with one academic discipline to the exclusion of others, for the distinction between
disciplines is purely artificial.  (And we invent specialized languages that tend to preserve these
artificial boundaries).  Never specialize to the point where you fail to see the wonderful things being
done elsewhere that may give you great insights into your own field.
</p>

<p><em>Thank you!</em></p>

<p>
<em>Profiled by Greg Cooper</em>
</p>

 </div>

 <div id="footer">
  <br>

  <a href="http://www.acm.org/">ACM Home</a> |
  <a href="http://www.acm.org/sigs/">ACM SIGs Home</a> |
  <a href="http://www.acm.org/sigsoft/">SIGSOFT Home</a> |
  <a href="http://www.acm.org/sigsoft/SEN/">SEN Home</a>

  <br><br>

  <small><em>
  Originally published in SEN vol. 23 no. 4, July 1998<br>
  Last update: 31 May 2007<br>
  </em></small>

 </div>
</div>
</body>
</html>

