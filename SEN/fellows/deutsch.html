<html>
<head>
<title>ACM SIGSOFT SEN: ACM Fellow L. Peter Deutsch</title>
<link rel="stylesheet" href="../sen.css" type="text/css">
</head>

<body>
<div id="container">
 <div id="banner">
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
   <tr>
    <td width="50%" valign="top" align="left"><img src="../images/sen_chevron_med.png" alt="Software Engineering Notes"></td>
    <td width="30%" valign="middle" align="center"><a href="http://www.acm.org/"><img src="../images/acmlogo_sg2007b.png" alt="ACM: Association for Computing Machinery" border="0"></a></td>
    <td width="20%" valign="middle" align="center"><a href="http://www.sigsoft.org/"><img src="../images/sigsoft_vsml.png" alt="SIGSOFT: Special Interest Group on Software Engineering" border="0"></a></td>
   </tr>
  </table>
 </div>

<div align="center"><br>
  <h2><em>ACM Fellow Profile</em><br>
  L. Peter Deutsch</h2>
</div>

<div class="indent10_10">
<p>
<strong><em>Please elaborate on the work leading up to your achieving the distinction of ACM Fellow:</em></strong><br>
The greatest part of my career has been concerned with
improving the ease of using computers and the ease of
developing quality software.  This desire led me into a
variety of activities related to programming languages,
interpreters, compilers, and tools.
</p>

<p>
<strong><em>What is the best reference to your work?</em></strong><br>
There is no single good reference, since most of my work
took the form of working systems rather than publications.
I was a substantial contributor to Interlisp and to
ParcPlace (now ObjectShare) Smalltalk (now VisualWorks).  My
two best published papers were my Ph.D. thesis, published by
Xerox PARC in 1971, and the paper I co-authored in the 1984
ACM POPL.
</p>

<p>
<strong><em>What are your current research interests?</em></strong><br>
I have been doing engineering in industry since 1991 and
wouldn't say I have research interests per se at the moment.
However, I continue to be deeply interested in tools and
languages that support the productive creation of high-
quality software, and specifically in the area of machine-
checkable, formally stated properties of programs.
</p>

<p>
<strong><em>What are your current outside interests?</em></strong><br>
Assuming you mean outside software engineering, I enjoy
traveling, singing, square dancing, writing music, and cheap
ethnic restaurants.
</p>

<p>
<strong><em>What was the greatest influence on you?</em></strong><br>
Lisp, which made me aware that software could be close to
executable mathematics; Smalltalk, which made me aware of
the synergy between language, tools, and libraries in
software productivity; and the PDP-1 time-sharing project at
MIT in the early 1960s, which introduced me to interactive
computing.  In terms of people, I would say Danny Bobrow,
for being a mentor and collaborator when I was in high
school and college; Robert Floyd, for the 1971 IFIP paper
that motivated my Ph.D. work; and Edsger Dijkstra, for
insisting that software is mathematics.
</p>

<p>
<strong><em>What was your greatest influence?</em></strong><br>
I think I have had two significant influences on the world
of software.  The 1984 POPL paper is the most widely cited
reference for what is now called JIT compilation.  The other
influence has been through my Ghostscript software, which
both has been of tremendous practical benefit and also has
an innovative licensing approach.  Beyond that, I have no
idea to what extent the various tools and implementation
techniques I contributed to the Interlisp and Smalltalk
systems have affected the industry.
</p>

<p>
<strong><em>Who do you think has made the greatest impact on software engineering?</em></strong><br>
I think the greatest impact on software engineering has come
from the development of better languages. I would hesitate
to choose between John Backus, for FORTRAN, and Thompson and
Ritchie, for C.
</p>

<p>
<strong><em>Which computer-related areas are most in need of investment by government,
business or education?</em></strong><br>
The government desperately needs to be better educated so
that it can start to undo the deleterious effects of
software patents (by reversing the error of interpretation
by the courts that allowed them in the first place) and of
Microsoft's desktop hegemony (by understanding that
seamlessly interoperable software does not require single-
sourcing the entire collection, and that interoperability
without a requirement of timely, free, and open
documentation of interfaces makes creative competition
impossible). Beyond that, see my advice below.
</p>

<p>
<strong><em>What advice do you have for computer science/software engineering students?</em></strong><br>
<ol>
<li>Good software requires the ability to think formally
(mathematically), even more than other kinds of engineering.
Make sure you have some exposure to assertions, proofs, and
analysis of algorithms, and that you use them enough to
understand what they are good for.
</li>
<li>On the other hand, so-called "formal methods" of software
development processes are vastly overrated: don't hesitate
to challenge them if they get in your way.
</li>
<li>Documentation and readability are as important to
software quality in the long run as speed of creation,
correct functioning, and performance are in the short run:
make sure you have the time to do a good job on them.
</li>
</ol>
</p>

<p>
<strong><em>What is the most often-overlooked risk in software engineering?</em></strong><br>
That as a system grows over time, it will become too complex
or disjointed to understand or make work reliably.
</p>

<p>
<strong><em>What is the most-repeated mistake in software engineering?</em></strong><br>
Underestimating the time or effort required to complete a
project.
</p>

<p>
<strong><em>Do you have any other comments on software engineering?</em></strong><br>
"Software engineering" is something of an oxymoron. It's
very difficult to have real engineering before you have
physics, and there isn't anything even close to a physics
for software -- an account of elementary objects in terms
that can be used to usefully describe and understand the
composites that are built out of them, including the
emergent properties of those composites.  If the individual
statements of programming languages are the elementary
particles, standard libraries are the building materials: we
have the standard C libraries (which are at about the
conceptual level of things like clay, rock, and wood), a
rich but proprietary (single-source, hidden-construction)
array of single-source libraries from Microsoft, and the
emerging Java standard libraries, none of which have the
formal specifications that are needed to make them good
building materials.
</p>

<p><em>Thank you!</em></p>

<p>
<em>Profiled by Ron Finkbine, Ph.D., <a href=mailto:finkbine@hanover.edu>finkbine@hanover.edu</a></em>
</p>

 </div>

 <div id="footer">
  <br>

  <a href="http://www.acm.org/">ACM Home</a> |
  <a href="http://www.acm.org/sigs/">ACM SIGs Home</a> |
  <a href="http://www.acm.org/sigsoft/">SIGSOFT Home</a> |
  <a href="http://www.acm.org/sigsoft/SEN/">SEN Home</a>

  <br><br>

  <small><em>
  Originally published in SEN vol. 24 no. 1, January 1999<br>
  Last update: 31 May 2007<br>
  </em></small>

 </div>
</div>
</body>
</html>

